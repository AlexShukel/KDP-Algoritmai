/**
 * @file generate-problems.ts
 * @description
 * This script generates a suite of Vehicle Routing Problem (VRP) instances
 * for benchmarking and testing purposes.
 *
 * Workflow:
 * 1. Loads the master datasets (orders and vehicles) generated by `generate-data.ts`.
 * 2. Iterates through a complexity matrix (varying number of vehicles vs. number of orders).
 * 3. Generates randomized problem instances by sampling unique subsets from the master data.
 * 4. Outputs individual JSON files into a structured directory tree `problems/<vCount>_<oCount>/`.
 */

import fs from 'fs/promises';
import path from 'path';

import { orderJsonSchema, Problem, vehicleJsonSchema } from './src/types/types';

const dataDir = path.resolve(__dirname, 'data');
const ordersJsonPath = path.resolve(dataDir, 'orders_1767435705599.json');
const vehiclesJsonPath = path.resolve(dataDir, 'vehicles_1767435705599.json');

const MIN_SIZE = 1;
const MAX_SIZE = 12;
const SAMPLES_PER_GROUP = 10;
const problemsDir = path.resolve(__dirname, 'problems');

const getRandomSubset = <T>(items: T[], count: number): T[] => {
    const selectedIndices = new Set<number>();
    const result: T[] = [];
    const totalItems = items.length;

    while (result.length < count) {
        const randomIndex = Math.floor(Math.random() * totalItems);

        if (!selectedIndices.has(randomIndex)) {
            selectedIndices.add(randomIndex);
            result.push(items[randomIndex]);
        }
    }

    return result;
};

const main = async () => {
    const timestamp = Date.now();

    const [ordersJsonRaw, vehiclesJsonRaw] = await Promise.all([
        fs.readFile(ordersJsonPath).then(val => val.toString()),
        fs.readFile(vehiclesJsonPath).then(val => val.toString()),
    ]);

    const allOrders = orderJsonSchema.array().parse(JSON.parse(ordersJsonRaw));
    const allVehicles = vehicleJsonSchema.array().parse(JSON.parse(vehiclesJsonRaw));

    for (let vCount = MIN_SIZE; vCount <= MAX_SIZE; ++vCount) {
        for (let oCount = MIN_SIZE; oCount <= MAX_SIZE; ++oCount) {
            const dirName = `${vCount}_${oCount}`;
            const targetDir = path.resolve(problemsDir, dirName);
            await fs.mkdir(targetDir, { recursive: true });

            const filesPromise: Promise<void>[] = [];

            for (let i = 0; i < SAMPLES_PER_GROUP; ++i) {
                const vehicles = getRandomSubset(allVehicles, vCount);
                const orders = getRandomSubset(allOrders, oCount);

                const problem = {
                    vehicles,
                    orders,
                    constraints: {
                        maxTotalDistance: 1200,
                    },
                } satisfies Problem;

                const fileName = `${i}_${timestamp}.json`;
                const filePath = path.join(targetDir, fileName);

                filesPromise.push(fs.writeFile(filePath, JSON.stringify(problem, null, 2)));
            }

            await Promise.all(filesPromise);
        }
    }
};

main().catch(err => {
    console.error(err);
    process.exit(1);
});
